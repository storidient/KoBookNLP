# -*- coding: utf-8 -*-
"""인데과 졸업 프로젝트 데이터 시각화

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18153lm7LciS_BI72ruolbA77sfEC02jz

# 데이터 준비
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import os
import json
import re
import numpy as np
from ast import literal_eval
from tqdm import tqdm
from collections import defaultdict
from unicodedata import normalize
from pathlib import Path

input_dir = '/content/drive/MyDrive/한국어근대소설_정제/완료/my_coref/'
files = sorted(os.listdir(input_dir), key = lambda x : (int(x.split('_')[0]),int(x.split('_')[1])))

def openjson(input_path):
  with open(input_path, 'r', encoding = 'UTF-8') as f:
    json_data = json.load(f)

  data = json.dumps(json_data, ensure_ascii = False)
  return literal_eval(data)

novel2eps = defaultdict(list)
ep_len = []

for d in tqdm(files):
  input_path = input_dir + d
  data = openjson(input_path)
  title = '_'.join(d.split('_')[2:]).replace('.json', '')
  title = normalize('NFC', title)
  novel2eps['청춘' if '청춘' in title else title].append(data)

"""JSON 문서를 불러와서, 데이터 형태 확인

소설: 원문, 상호참조해결 주석...

3인의 주석자들의 주석 중 3인 모두 일치하는 것만 추출(final_coref)
"""

novel2eps

for title in novel2eps:
  for scene in novel2eps[title]:
    final_coref = set(scene['raw_coref']) & set(scene['surin_coref']) & set(scene['my_coref'])
    scene['final_coref'] = final_coref

novel2eps['청춘']

"""현재 가지고 있는 정보:
final_coref에 각 멘션당

1. 시작 인덱스
2. 끝 인덱스
3. 레이블
4. 멘션

시작 인덱스-끝 인덱스를 잇는 선분으로 하나의 멘션 표시

"""

labels = {}
for title in novel2eps:
  labels_per_novel = []
  for scene in novel2eps[title]:
    labels_per_novel.extend(scene['final_coref'])
  labels[title] = labels_per_novel

labels

len(labels)

char_labels = {}
for novel in labels.keys():
  labels_per_character = {}
  for i in labels[novel]:
    info = i.split("#")
    character = info[2]
    idx = (info[0], info[1])
    try:
      labels_per_character[character].append(idx)
    except:
      labels_per_character[character] = []
      labels_per_character[character].append(idx)

  char_labels[novel] = labels_per_character

char_labels

"""# 그래프 그리기

각 멘션당 (시작 인덱스, 끝 인덱스) 형태의 tuple 얻기
"""

import matplotlib.pyplot as plt
import hashlib

# Function to convert string tuples to integers
def convert_to_int_tuples(data):
    return [(int(start), int(end)) for start, end in data]

# Create figure and axis
fig, ax = plt.subplots()

# Define a consistent color mapping based on key names
colors = {}
for key in data.keys():
    color_hash = hashlib.sha256(key.encode()).hexdigest()[:6]  # Using first 6 characters of SHA256 hash as color
    colors[key] = f'#{color_hash}'

y_ticks = list(data.keys())  # Get the keys as y-axis ticks

y_counter = 1  # Starting y-coordinate for all ranges

# Loop through each key and plot the spans using plot with assigned colors
legend_handles = []  # To store legend handles
for key, spans in data.items():
    spans = convert_to_int_tuples(spans)
    for start, end in spans:
        line, = ax.plot([start, end], [key, key], color=colors[key], alpha=0.5, linewidth=3)  # Increase linewidth to 2
    y_counter += 1
    # Store only one legend handle per key
    legend_handles.append(line)

for title in char_labels.keys():
  try:

    convert_to_int_tuples(char_labels[title])
    # Customize plot
    ax.set_yticks(y_ticks)  # Setting y-axis ticks with key names
    ax.set_yticklabels(y_ticks)  # Labeling y-axis ticks with key names
    ax.set_xlabel('Value')
    ax.set_title(title)

    # Display legend with key names and colors
    ax.legend(legend_handles, data.keys(), bbox_to_anchor=(1.05, 1), loc='upper left', title='Key')

    plt.grid(True)
    plt.show()

  except:
    pass

"""각 멘션별 튜플을 순회하며 선분 그리기"""

import matplotlib.font_manager as fm
import matplotlib.pyplot as plt
import hashlib

def plot_multiple_ranges(data, title):
    # Function to convert string tuples to integers
    def convert_to_int_tuples(data):
        return [(int(start), int(end)) for start, end in data]

    # Create figure and axis
    fig, ax = plt.subplots()


    # Define a consistent color mapping based on key names
    colors = {}
    for key in data.keys():
        color_hash = hashlib.sha256(key.encode()).hexdigest()[:6]  # Using first 6 characters of SHA256 hash as color
        colors[key] = f'#{color_hash}'

    y_ticks = list(data.keys())  # Get the keys as y-axis ticks

    y_counter = 1  # Starting y-coordinate for all ranges

    # Loop through each key and plot the spans using plot with assigned colors
    legend_handles = []  # To store legend handles
    for key, spans in data.items():
        spans = convert_to_int_tuples(spans)
        for start, end in spans:
            line, = ax.plot([start, end], [key, key], color=colors[key], alpha=0.5, linewidth=3)  # Increase linewidth to 2
        y_counter += 1
        # Store only one legend handle per key
        legend_handles.append(line)

    # Customize plot
    ax.set_yticks(y_ticks)  # Setting y-axis ticks with key names
    ax.set_yticklabels(y_ticks)  # Labeling y-axis ticks with key names
    ax.set_xlabel('Value')
    ax.set_title(title)

    # Increase vertical space by extending the y-axis limits
    ax.set_ylim(-0.5, len(y_ticks) - 0.5)  # Adjusting y-axis limits for increased spacing

    # Display legend with key names and colors
    ax.legend(legend_handles, data.keys(), bbox_to_anchor=(1.05, 1), loc='upper left', title='Key')

    # 폰트 설정
    plt.rc('font', family='NanumGothic')

    plt.grid(True)
    plt.show()

import matplotlib.font_manager as fm
import os
import matplotlib.pyplot as plt

# apt-get : 패키지 설치 명령어
# -qq : 에러외의 메세지 숨기는 옵션키
!apt-get -qq install fonts-nanum


fe = fm.FontEntry(
    fname=r'/usr/share/fonts/truetype/nanum/NanumGothic.ttf', # ttf 파일이 저장되어 있는 경로
    name='NanumGothic')                        # 이 폰트의 원하는 이름 설정
fm.fontManager.ttflist.insert(0, fe)              # Matplotlib에 폰트 추가
plt.rcParams.update({'font.size': 10, 'font.family': 'NanumGothic'}) # 폰트 설정

"""결과"""

for data in char_labels.keys():
  plot_multiple_ranges(char_labels[data], data)